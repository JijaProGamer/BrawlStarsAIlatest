<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TensorFlow.js with WebGL Example</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4"></script>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script>
        const renderBoxes = (canvasRef, boxes_data, scores_data, classes_data, ratios) => {
            const ctx = canvasRef.getContext("2d");
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // clean canvas

            const colors = new Colors();

            // font configs
            const font = `${Math.max(
                Math.round(Math.max(ctx.canvas.width, ctx.canvas.height) / 40),
                14
            )}px Arial`;
            ctx.font = font;
            ctx.textBaseline = "top";

            for (let i = 0; i < scores_data.length; ++i) {
                // filter based on class threshold
                const klass = labels[classes_data[i]];
                const color = colors.get(classes_data[i]);
                const score = (scores_data[i] * 100).toFixed(1);

                let [y1, x1, y2, x2] = boxes_data.slice(i * 4, (i + 1) * 4);
                x1 *= ratios[0];
                x2 *= ratios[0];
                y1 *= ratios[1];
                y2 *= ratios[1];
                const width = x2 - x1;
                const height = y2 - y1;

                // draw box.
                ctx.fillStyle = Colors.hexToRgba(color, 0.2);
                ctx.fillRect(x1, y1, width, height);

                ctx.strokeStyle = color;
                ctx.lineWidth = Math.max(Math.min(ctx.canvas.width, ctx.canvas.height) / 200, 2.5);
                ctx.strokeRect(x1, y1, width, height);

                ctx.fillStyle = color;
                const textWidth = ctx.measureText(klass + " - " + score + "%").width;
                const textHeight = parseInt(font, 10); // base 10
                const yText = y1 - (textHeight + ctx.lineWidth);
                ctx.fillRect(
                    x1 - 1,
                    yText < 0 ? 0 : yText,
                    textWidth + ctx.lineWidth,
                    textHeight + ctx.lineWidth
                );

                ctx.fillStyle = "#ffffff";
                ctx.fillText(klass + " - " + score + "%", x1 - 1, yText < 0 ? 0 : yText);
            }
        };

        const threshold = 0.75;

        let classesDir = {
            1: {
                name: 'Kangaroo',
                id: 1,
            },
            2: {
                name: 'Other',
                id: 2,
            }
        }

        let model;
        const socket = new WebSocket(`ws://localhost:${parseInt(location.port) + 1}`);

        socket.addEventListener("open", (event) => {

        });

        socket.addEventListener("message", async (event) => {
            if (!model) {
                await getModel()
            }

            let start = performance.now();
            let data = JSON.parse(event.data)

            /*const imageData = createImageDataFromBMP(data);

            document.querySelector("canvas").width = 296
            document.querySelector("canvas").height = 136
            document.querySelector("canvas").getContext("2d").putImageData(imageData, 0, 0)*/

            tf.engine().startScope();

            /*const imgTensor = tf.browser.fromPixels(imageData).toInt()
                .transpose([0, 1, 2]).expandDims();*/

            const image = tf.tensor(data.data, data.shape, "int32")

            const imgTensor = image
                .transpose([0, 1, 2]).expandDims()

            model.executeAsync(imgTensor).then(predictions => {
                predictions = getPredictions(predictions);

                socket.send(JSON.stringify({ id: data.id, predictions }))

                tf.engine().endScope();
            });
        });

        async function getModel() {
            await tf.setBackend('webgl');
            await tf.ready();

            model = await tf.loadGraphModel("https://raw.githubusercontent.com/hugozanini/TFJS-object-detection/master/models/kangaroo-detector/model.json");
        }


        function buildDetectedObjects(scores, threshold, boxes, classes) {
            const detectionObjects = []

            scores[0].forEach((score, i) => {
                if (score > threshold) {
                    const bbox = [];
                    const minY = boxes[0][i][0];
                    const minX = boxes[0][i][1];
                    const maxY = boxes[0][i][2];
                    const maxX = boxes[0][i][3];
                    bbox[0] = minX;
                    bbox[1] = minY;
                    bbox[2] = maxX - minX;
                    bbox[3] = maxY - minY;

                    detectionObjects.push({
                        class: classes[i],
                        label: classesDir[classes[i]].name,
                        score: score.toFixed(4),
                        bbox: bbox
                    })
                }
            })

            return detectionObjects
        }

        function getPredictions(predictions) {
            const boxes = predictions[4].arraySync();
            const scores = predictions[5].arraySync();
            const classes = predictions[6].dataSync();
            const detections = buildDetectedObjects(scores, threshold, boxes, classes);

            return detections
        }
    </script>

    <style>
        #canvas {
            display: block;
            width: 80vw;
        }
    </style>
</body>

</html>