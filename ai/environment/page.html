<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Environment Model</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.1.0"></script>
</head>

<body>
    <script>        
        let constants;
        let labels;
        let model_size;

        let model;
        const socket = new WebSocket(`ws://localhost:${parseInt(location.port) + 1}`);

        socket.addEventListener("open", (event) => {

        });

        socket.addEventListener("message", async (event) => {
            if (!model) {
                await getModel();
            }

            let data = JSON.parse(event.data);

            const imageData = createImageDataFromRGBArray(data.image, data.resolution);

            let xRatio, yRatio;

            const [boxes, scores, classes] = tf.tidy(() => {
                const maxSize = Math.max(data.resolution[0], data.resolution[1]);
                xRatio = maxSize / data.resolution[0];
                yRatio = maxSize / data.resolution[1];

                const imgTensor = tf.image.resizeBilinear(tf.browser.fromPixels(imageData), [model_size, model_size])
                                .div(255.0)
                                .expandDims(0);

                // execute model

                const res = model.execute(imgTensor);

                const transRes = res.transpose([0, 2, 1]);
                const boxes = tf.tidy(() => {
                    const w = transRes.slice([0, 0, 2], [-1, -1, 1]);
                    const h = transRes.slice([0, 0, 3], [-1, -1, 1]);
                    const x1 = tf.sub(transRes.slice([0, 0, 0], [-1, -1, 1]), tf.div(w, 2));
                    const y1 = tf.sub(transRes.slice([0, 0, 1], [-1, -1, 1]), tf.div(h, 2));
                    return tf
                        .concat(
                            [
                                y1,
                                x1,
                                tf.add(y1, h),
                                tf.add(x1, w),
                            ],
                            2
                        )
                        .squeeze();
                });

                const [scores, classes] = tf.tidy(() => {
                    const rawScores = transRes.slice([0, 0, 4], [-1, -1, labels.length]).squeeze(0);
                    return [rawScores.max(1), rawScores.argMax(1)];
                });
                
                return [boxes, scores, classes]
            })

            const nms = await tf.image.nonMaxSuppressionAsync(boxes, scores, 30, 0.45, 0.2);

            const boxes_data = boxes.gather(nms, 0).dataSync();
            const scores_data = scores.gather(nms, 0).dataSync();
            const classes_data = classes.gather(nms, 0).dataSync();

            tf.dispose([nms, boxes, scores, classes])

            const predictions = convertPredictions(boxes_data, scores_data, classes_data, [xRatio, yRatio], data.resolution);
            socket.send(JSON.stringify({ id: data.id, predictions: predictions }));
        });

        function createImageDataFromRGBArray(rgbArray, resolution) {
            const [width, height] = resolution;
            const rgbaArray = new Uint8ClampedArray(width * height * 4);

            for (let i = 0, j = 0; i < rgbArray.length; i += 3, j += 4) {
                rgbaArray[j] = rgbArray[i];
                rgbaArray[j + 1] = rgbArray[i + 1];
                rgbaArray[j + 2] = rgbArray[i + 2];
                rgbaArray[j + 3] = 255;
            }

            return new ImageData(rgbaArray, width, height);
        }

        async function getModel() {
            await tf.setBackend('webgl');
            await tf.ready();

            model = await tf.loadGraphModel("/model.json");
            constants = await (await fetch("/constants.json")).json();

            labels = constants.labels;
            model_size = constants.model_size;
        }


        function convertPredictions(boxes_data, scores_data, classes_data, ratios, resolution) {
            const predictions = []

            for (let i = 0; i < scores_data.length; ++i) {
                const klass = labels[classes_data[i]];
                const score = (scores_data[i] * 100).toFixed(1);

                let [y1, x1, y2, x2] = boxes_data.slice(i * 4, (i + 1) * 4);

                predictions.push({
                    class: klass,
                    score,
                    x1: x1 / ratios[0] / resolution[0],
                    x2: x2 / ratios[0] / resolution[0],
                    y1: y1 / ratios[1] / resolution[1],
                    y2: y2 / ratios[1] / resolution[1],
                })
            }

            return predictions
        }
    </script>
</body>

</html>