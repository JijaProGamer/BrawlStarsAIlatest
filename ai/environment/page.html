<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TensorFlow.js with WebGL Example</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.1.0"></script>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script>        
        const threshold = 0.75;

        let labels = [
            "Ball",
            "Enemy",
            "Friendly",
            "Gem",
            "Hot_Zone",
            "Me",
            "PP",
            "PP_Box",
            "Safe_Enemy",
            "Safe_Friendly"
        ]

        let model;
        const socket = new WebSocket(`ws://localhost:${parseInt(location.port) + 1}`);
        const canvas = document.querySelector("canvas");
        const context = canvas.getContext("2d", {willReadFrequently: true, desynchronized: true})

        socket.addEventListener("open", (event) => {

        });

        socket.addEventListener("message", async (event) => {
            if (!model) {
                await getModel();
            }

            let data = JSON.parse(event.data);

            data.resolution[1] = data.resolution[0]; // remove after retrain

            const imageData = createImageDataFromRGBArray(data.image, data.resolution);

            canvas.width = data.resolution[0];
            canvas.height = data.resolution[1];
            context.putImageData(imageData, 0, 0);

            // resize the frame

            let xRatio, yRatio

            const [boxes, scores, classes] = tf.tidy(() => {
                const maxSize = Math.max(data.resolution[0], data.resolution[1]);
                const img = tf.browser.fromPixels(context.getImageData(0, 0, data.resolution[0], data.resolution[0]))
                const imgPadded = img.pad([
                    [0, maxSize - data.resolution[1]],
                    [0, maxSize - data.resolution[0]],
                    [0, 0],
                ]);

                xRatio = maxSize / data.resolution[0];
                yRatio = maxSize / data.resolution[1];

                const imgTensor = tf.image
                    .resizeBilinear(imgPadded, [data.resolution[0], data.resolution[1]])
                    .div(255.0)
                    .expandDims(0);


                // execute model

                const res = model.execute(imgTensor);


                const transRes = res.transpose([0, 2, 1]);
                const boxes = tf.tidy(() => {
                    const w = transRes.slice([0, 0, 2], [-1, -1, 1]);
                    const h = transRes.slice([0, 0, 3], [-1, -1, 1]);
                    const x1 = tf.sub(transRes.slice([0, 0, 0], [-1, -1, 1]), tf.div(w, 2));
                    const y1 = tf.sub(transRes.slice([0, 0, 1], [-1, -1, 1]), tf.div(h, 2));
                    return tf
                        .concat(
                            [
                                y1,
                                x1,
                                tf.add(y1, h),
                                tf.add(x1, w),
                            ],
                            2
                        )
                        .squeeze();
                });

                const [scores, classes] = tf.tidy(() => {
                    const rawScores = transRes.slice([0, 0, 4], [-1, -1, labels.length]).squeeze(0);
                    return [rawScores.max(1), rawScores.argMax(1)];
                });
                
                return [boxes, scores, classes]
            })

            const nms = await tf.image.nonMaxSuppressionAsync(boxes, scores, 500, 0.45, 0.2);

            const boxes_data = boxes.gather(nms, 0).dataSync();
            const scores_data = scores.gather(nms, 0).dataSync();
            const classes_data = classes.gather(nms, 0).dataSync();

            tf.dispose([nms, boxes, scores, classes])

            const predictions = convertPredictions(boxes_data, scores_data, classes_data, [xRatio, yRatio], data.resolution);
            socket.send(JSON.stringify({ id: data.id, predictions: predictions }));
        });

        function createImageDataFromRGBArray(rgbArray, resolution) {
            const [width, height] = resolution;
            const rgbaArray = new Uint8ClampedArray(width * height * 4);

            for (let i = 0, j = 0; i < rgbArray.length; i += 3, j += 4) {
                rgbaArray[j] = rgbArray[i];
                rgbaArray[j + 1] = rgbArray[i + 1];
                rgbaArray[j + 2] = rgbArray[i + 2];
                rgbaArray[j + 3] = 255;
            }

            return new ImageData(rgbaArray, width, height);
        }

        async function getModel() {
            await tf.setBackend('webgl');
            await tf.ready();

            model = await tf.loadGraphModel("/model.json");
        }


        function convertPredictions(boxes_data, scores_data, classes_data, ratios, resolution) {
            const predictions = []

            for (let i = 0; i < scores_data.length; ++i) {
                const klass = labels[classes_data[i]];
                const score = (scores_data[i] * 100).toFixed(1);

                let [y1, x1, y2, x2] = boxes_data.slice(i * 4, (i + 1) * 4);

                predictions.push({
                    class: klass,
                    score,
                    x1: x1 * ratios[0] / resolution[0],
                    x2: x2 * ratios[0] / resolution[0],
                    y1: y1 * ratios[1] / resolution[1],
                    y2: y2 * ratios[1] / resolution[1],
                })
            }

            return predictions
        }
    </script>

    <style>
        #canvas {
            display: block;
            width: 80vw;
        }
    </style>
</body>

</html>