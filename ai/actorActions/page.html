<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actor Actions Model</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.1.0"></script>
</head>

<body>
    <script>
        let constants;
        let detectionSettings;
        let labels;
        let model_size;

        let model;
        const socket = new WebSocket(`ws://localhost:${parseInt(location.port) + 1}`);

        socket.addEventListener("open", (event) => {

        });

        socket.addEventListener("message", async (event) => {
            if (!model) {
                await getModel();
            }

            let data = JSON.parse(event.data);

            const imageData = createImageDataFromRGBArray(data.image, data.resolution);

            const [boxes, scores, classes] = tf.tidy(() => {
                const imgTensor = tf.image.resizeBilinear(tf.browser.fromPixels(imageData), [model_size[1], model_size[0]])
                    .div(255.0)
                    .expandDims(0);

                // execute model

                const res = model.execute(imgTensor);

                const transRes = res.transpose([0, 2, 1]);
                const boxes = tf.tidy(() => {
                    const w = transRes.slice([0, 0, 2], [-1, -1, 1]);
                    const h = transRes.slice([0, 0, 3], [-1, -1, 1]);
                    const x1 = tf.sub(transRes.slice([0, 0, 0], [-1, -1, 1]), tf.div(w, 2));
                    const y1 = tf.sub(transRes.slice([0, 0, 1], [-1, -1, 1]), tf.div(h, 2));
                    return tf
                        .concat(
                            [
                                y1,
                                x1,
                                tf.add(y1, h),
                                tf.add(x1, w),
                            ],
                            2
                        )
                        .squeeze();
                });

                const [scores, classes] = tf.tidy(() => {
                    const rawScores = transRes.slice([0, 0, 4], [-1, -1, labels.length]).squeeze(0);
                    return [rawScores.max(1), rawScores.argMax(1)];
                });

                return [boxes, scores, classes]
            })

            const nms = await tf.image.nonMaxSuppressionAsync(boxes, scores, 500, detectionSettings.iouThreshold, detectionSettings.scoreThreshold);

            //console.time("nms")
            //const nms = tf.image.nonMaxSuppressionWithScore(boxes, scores, 500, detectionSettings.iouThreshold, detectionSettings.scoreThreshold, detectionSettings.softNmsSigma);
            //const nms = tf.image.nonMaxSuppression(boxes, scores, 15, detectionSettings.iouThreshold, detectionSettings.scoreThreshold);
            //console.timeEnd("nms")

            const boxes_data = boxes.gather(nms, 0).dataSync();
            const scores_data = scores.gather(nms, 0).dataSync();
            const classes_data = classes.gather(nms, 0).dataSync();

            tf.dispose([nms, boxes, scores, classes])

            const predictions = convertPredictions(boxes_data, scores_data, classes_data, data.resolution);

            /*console.time("nms")
            const boxesData = await boxes.data();//Array.from(boxes.dataSync());
            const scoresData = await scores.data();
            const classesData = await classes.data();
            console.timeEnd("nms")

            const nms = nonMaxSuppression([], [], []);
            //console.timeEnd("nms")

            tf.dispose([boxes, scores, classes])

            const predictions = convertPredictions(nms.boxes_data, nms.scores_data, nms.classes_data, [xRatio, yRatio], data.resolution);*/


            socket.send(JSON.stringify({ id: data.id, predictions: predictions }));
        });

        /*function nonMaxSuppression(boxes, scores, classes) {
            boxes = Array.from({ length: boxes.length / 4 }, (_, i) => boxes.slice(i * 4, i * 4 + 4));

            let boxes_data = [];
            let scores_data = [];
            let classes_data = [];

            for (let i = 0; i < boxes.length; i++) {
                let currentBox = boxes[i];
                let currentScore = scores[i];
                let currentClass = classes[i];

                if (currentScore >= detectionSettings.scoreThreshold) {
                    let shouldAdd = true;

                    for (let j = 0; j < boxes_data.length; j++) {
                        let existingBox = boxes_data[j];
                        let existingClass = classes_data[j];

                        if (existingClass !== currentClass) {
                            continue;
                        }

                        let iou = calculateIOU(currentBox, existingBox);

                        if (iou >= detectionSettings.iouThreshold) {
                            shouldAdd = false;
                            break;
                        }
                    }

                    if (shouldAdd) {
                        boxes_data.push(currentBox);
                        scores_data.push(currentScore);
                        classes_data.push(currentClass);
                    }
                }
            }

            return {
                boxes_data: boxes_data.flat(),
                scores_data: scores_data,
                classes_data: classes_data
            };
        }*/

        function nonMaxSuppression(boxes, scores, classes) {
            let output = {
                boxes_data: [],
                scores_data: [],
                classes_data: []  
            }

            /*for(let i = 0; i < boxes.length; i += 4){
                if(scores[i/4] >= detectionSettings.scoreThreshold){
                    output.boxes_data.push(boxes[i], boxes[i + 1], boxes[i + 2], boxes[i + 3])
                    output.scores_data.push(scores[i])
                    output.classes_data.push(classes[i])
                }
            }*/

            return output
        }

        function calculateIOU(box1, box2) {
            let [y1_1, x1_1, y2_1, x2_1] = box1;
            let [y1_2, x1_2, y2_2, x2_2] = box2;

            let xA = Math.max(x1_1, x1_2);
            let yA = Math.max(y1_1, y1_2);
            let xB = Math.min(x2_1, x2_2);
            let yB = Math.min(y2_1, y2_2);

            let interArea = Math.max(0, xB - xA + 1) * Math.max(0, yB - yA + 1);

            let box1Area = (x2_1 - x1_1 + 1) * (y2_1 - y1_1 + 1);
            let box2Area = (x2_2 - x1_2 + 1) * (y2_2 - y1_2 + 1);

            let unionArea = box1Area + box2Area - interArea;

            let iou = interArea / unionArea;
            return iou;
        }

        function createImageDataFromRGBArray(rgbArray, resolution) {
            const [width, height] = resolution;
            const rgbaArray = new Uint8ClampedArray(width * height * 4);

            for (let i = 0, j = 0; i < rgbArray.length; i += 3, j += 4) {
                rgbaArray[j] = rgbArray[i];
                rgbaArray[j + 1] = rgbArray[i + 1];
                rgbaArray[j + 2] = rgbArray[i + 2];
                rgbaArray[j + 3] = 255;
            }

            return new ImageData(rgbaArray, width, height);
        }

        async function getModel() {
            await tf.setBackend('webgl');
            await tf.ready();

            constants = await (await fetch("/constants.json")).json();
            detectionSettings = await (await fetch("/settings.json")).json();

            labels = constants.labels;
            model_size = constants.model_size;

            model = await tf.loadGraphModel("/model.json");
        }


        function convertPredictions(boxes_data, scores_data, classes_data, resolution) {
            const predictions = []

            for (let i = 0; i < scores_data.length; ++i) {
                const klass = labels[classes_data[i]];
                const score = (scores_data[i] * 100).toFixed(1);

                let [y1, x1, y2, x2] = boxes_data.slice(i * 4, (i + 1) * 4);

                predictions.push({
                    class: klass,
                    score,
                    x1: x1 / resolution[0],
                    x2: x2 / resolution[0],
                    y1: y1 / resolution[1],
                    y2: y2 / resolution[1],
                })
            }

            return predictions
        }
    </script>
</body>

</html>